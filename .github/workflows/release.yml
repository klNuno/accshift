name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve release tag
        id: release_tag
        shell: pwsh
        run: |
          $tag = "${env:GITHUB_REF_NAME}"

          if (-not $tag.StartsWith("v")) {
            throw "Invalid tag '$tag'. Expected format: vX.Y.Z"
          }

          $version = $tag.TrimStart("v")
          if ([string]::IsNullOrWhiteSpace($version)) {
            throw "Invalid tag '$tag'. Version is empty."
          }

          "tag=$tag" >> $env:GITHUB_OUTPUT
          "version=$version" >> $env:GITHUB_OUTPUT

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Validate versions against tag
        shell: pwsh
        run: |
          $tag = "${{ steps.release_tag.outputs.version }}"

          $packageVersion = (Get-Content package.json -Raw | ConvertFrom-Json).version
          $tauriVersion = (Get-Content src-tauri/tauri.conf.json -Raw | ConvertFrom-Json).version

          $cargoMatch = Select-String -Path src-tauri/Cargo.toml -Pattern '^version\s*=\s*"([^"]+)"' | Select-Object -First 1
          if (-not $cargoMatch) {
            throw "Could not read version from src-tauri/Cargo.toml"
          }
          $cargoVersion = $cargoMatch.Matches[0].Groups[1].Value

          if ($packageVersion -ne $tag -or $tauriVersion -ne $tag -or $cargoVersion -ne $tag) {
            throw "Version mismatch. tag=$tag package.json=$packageVersion tauri.conf.json=$tauriVersion Cargo.toml=$cargoVersion"
          }

      - name: Validate updater signing key secret
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          if ([string]::IsNullOrWhiteSpace($env:TAURI_SIGNING_PRIVATE_KEY)) {
            throw "Missing GitHub secret TAURI_SIGNING_PRIVATE_KEY. Auto-update artifacts cannot be signed."
          }

      - name: Build Tauri bundles
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: pnpm tauri build

      - name: Generate SHA256 checksums
        shell: pwsh
        run: |
          $bundleDir = "src-tauri/target/release/bundle"
          $files = @()
          $files += Get-ChildItem "$bundleDir/nsis/*.exe" -File -ErrorAction SilentlyContinue
          $files += Get-ChildItem "$bundleDir/msi/*.msi" -File -ErrorAction SilentlyContinue

          if ($files.Count -eq 0) {
            throw "No release artifacts found in $bundleDir"
          }

          $lines = $files | ForEach-Object {
            $hash = (Get-FileHash -Path $_.FullName -Algorithm SHA256).Hash.ToLower()
            "$hash  $($_.Name)"
          }

          $outFile = "$bundleDir/SHA256SUMS.txt"
          $lines | Set-Content -Path $outFile -Encoding ascii
          Get-Content $outFile

      - name: Generate release changelog
        id: changelog
        shell: pwsh
        run: |
          $tag = "${{ steps.release_tag.outputs.tag }}"
          $prevTag = ""
          try {
            $prevTag = (git describe --tags --abbrev=0 "$tag^" 2>$null).Trim()
          } catch {
            $prevTag = ""
          }

          $range = if ([string]::IsNullOrWhiteSpace($prevTag)) { $tag } else { "$prevTag..$tag" }

          # PowerShell returns command output as a string array; join once, then split by separators.
          $recordSeparator = [char]0x1e
          $fieldSeparator = [char]0x1f
          $raw = (git log --reverse --pretty=format:"%s%x1f%b%x1e" $range) -join "`n"
          $records = $raw -split $recordSeparator | Where-Object { -not [string]::IsNullOrWhiteSpace($_.Trim()) }

          function Normalize-Subject {
            param([string]$Subject)

            $normalized = $Subject.Trim()
            $normalized = $normalized -replace '^(build|chore|ci|docs|feat|fix|perf|refactor|revert|style|test)(\([^)]+\))?!?:\s*', ''
            if ([string]::IsNullOrWhiteSpace($normalized)) {
              return $Subject.Trim()
            }

            return $normalized
          }

          function Get-SectionName {
            param(
              [string]$Subject,
              [string]$NormalizedSubject
            )

            $lowerSubject = $Subject.ToLowerInvariant()
            $lowerNormalized = $NormalizedSubject.ToLowerInvariant()

            if ($lowerSubject -match '^(fix|hotfix)(\([^)]+\))?!?:' -or $lowerNormalized -match '^(fix|hotfix|bugfix)\b') {
              return "Fixes"
            }

            return "Changes"
          }

          $grouped = @{
            "Changes" = New-Object System.Collections.Generic.List[object]
            "Fixes" = New-Object System.Collections.Generic.List[object]
          }

          foreach ($record in $records) {
            $parts = $record.Split($fieldSeparator, 2)
            if ($parts.Count -lt 1) {
              continue
            }

            $subject = $parts[0].Trim()
            if ([string]::IsNullOrWhiteSpace($subject)) {
              continue
            }

            $body = if ($parts.Count -ge 2) { $parts[1] } else { "" }
            $details = @()
            if (-not [string]::IsNullOrWhiteSpace($body)) {
              $details = $body -split "\r?\n" |
                ForEach-Object { $_.Trim() } |
                Where-Object { $_ -like "- *" } |
                ForEach-Object { $_.Substring(2).Trim() }
            }

            $entry = [PSCustomObject]@{
              Subject = Normalize-Subject -Subject $subject
              Details = $details
            }

            $section = Get-SectionName -Subject $subject -NormalizedSubject $entry.Subject
            $grouped[$section].Add($entry)
          }

          $notes = New-Object System.Collections.Generic.List[string]

          foreach ($section in @("Changes", "Fixes")) {
            if ($grouped[$section].Count -eq 0) {
              continue
            }

            $notes.Add("## $section")
            $notes.Add("")

            foreach ($entry in $grouped[$section]) {
              if ($entry.Details.Count -gt 0) {
                $notes.Add("- $($entry.Subject): $($entry.Details -join '; ')")
              } else {
                $notes.Add("- $($entry.Subject)")
              }
            }

            $notes.Add("")
          }

          if ($notes.Count -eq 0) {
            $notes.Add("## Changes")
            $notes.Add("")
            $notes.Add("- No changelog entries found.")
          }

          $notesText = ($notes -join "`n").Trim()
          if ([string]::IsNullOrWhiteSpace($notesText)) {
            $notesText = "## Changes`n`n- No changelog entries found."
          }

          Set-Content -Path RELEASE_NOTES.md -Value $notesText -Encoding utf8
          Get-Content RELEASE_NOTES.md

          "body<<EOF" >> $env:GITHUB_OUTPUT
          $notesText >> $env:GITHUB_OUTPUT
          "EOF" >> $env:GITHUB_OUTPUT

      - name: Generate updater manifest
        shell: pwsh
        run: |
          $tag = "${{ steps.release_tag.outputs.tag }}"
          $version = "${{ steps.release_tag.outputs.version }}"
          $repo = "${{ github.repository }}"
          $bundleDir = "src-tauri/target/release/bundle"

          $primaryAsset = Get-ChildItem "$bundleDir/nsis/*.exe" -File -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $primaryAsset) {
            $primaryAsset = Get-ChildItem "$bundleDir/msi/*.msi" -File -ErrorAction SilentlyContinue | Select-Object -First 1
          }
          if (-not $primaryAsset) {
            throw "Could not find a release installer asset (.exe or .msi) to reference in latest.json"
          }

          $sigPath = "$($primaryAsset.FullName).sig"
          if (-not (Test-Path $sigPath)) {
            throw "Missing updater signature file for $($primaryAsset.Name): $sigPath"
          }

          $signature = (Get-Content $sigPath -Raw).Trim()
          if ([string]::IsNullOrWhiteSpace($signature)) {
            throw "Signature file is empty: $sigPath"
          }

          $notes = (Get-Content RELEASE_NOTES.md -Raw).Trim()
          if ([string]::IsNullOrWhiteSpace($notes)) {
            $notes = "No changelog entries found."
          }

          $assetUrl = "https://github.com/$repo/releases/download/$tag/$($primaryAsset.Name)"

          $manifest = @{
            version = $version
            notes = $notes
            pub_date = (Get-Date).ToUniversalTime().ToString("o")
            platforms = @{
              "windows-x86_64" = @{
                signature = $signature
                url = $assetUrl
              }
            }
          }

          $manifestPath = Join-Path $bundleDir "latest.json"
          $manifest | ConvertTo-Json -Depth 8 | Set-Content -Path $manifestPath -Encoding utf8
          Get-Content $manifestPath

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_tag.outputs.tag }}
          draft: true
          generate_release_notes: false
          body: ${{ steps.changelog.outputs.body }}
          files: |
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/latest.json
